<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>所以然</title>
    <link>https://h3l.github.io/</link>
    <description>Recent content on 所以然</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 05 Jan 2020 22:40:42 +0800</lastBuildDate>
    
	<atom:link href="https://h3l.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>记 20200104 深圳 golang meetup</title>
      <link>https://h3l.github.io/posts/20200104-golang-meetup/</link>
      <pubDate>Sun, 05 Jan 2020 22:40:42 +0800</pubDate>
      
      <guid>https://h3l.github.io/posts/20200104-golang-meetup/</guid>
      <description>早早报名了 gocn 组织的深圳 Golang meetup，花了一整天，听了 7 个主题。简单分享如下。
1.Go在工业领域的应用实践 首先简单叙述了下现在工业领域的痛点主要是没有进行数字化。看不到数据，之后主要介绍他们公司使用 Golang 开发了系统提供给一些制造业的公司。通过对制造业的数字化，可以收集数据，帮助辅助化决策。
之后他们使用的 Golang 的原因是方便在各个平台部署。
借助 Golang 的 interface 能比较方便的对接各种底层硬件等。之后 show 了一点代码。
2.Go性能优化之路 首先提出优化是有成本的，要权衡优化的成本和价值，来决定做不做优化。
其次是什么时候停止优化，优化之前往往需要一个目标，因为优化这个过程是边际效用递减的，所以往往在优化到一定程度的时候就不需要继续优化了。
如何优化，演讲者明确的给了五步，最后一步为重复第一步，作为一个循环。具体五步如下：
  基准
  首先优化有个基准才能知道到底是正优化，还是负优化
  满足基准测试之前，首先要满足单元测试，首先对，然后才是快
  基准测试的工具主要是 benchmark
    分析
  主要是发现瓶颈，并定位瓶颈
  主要工具如下：
 GODEBUG，通过环境变量的设置，让 Golang 打印堆栈情况 go tool pprof，可以查看 heap, goroutine, cpu, memery 等情况的瓶颈 go tool trace      优化</description>
    </item>
    
    <item>
      <title>如何为 Mac 中不支持的快捷键的菜单栏加上快捷键</title>
      <link>https://h3l.github.io/posts/automation-with-applescript-and-keyboard-maestro/</link>
      <pubDate>Fri, 07 Dec 2018 23:10:38 +0800</pubDate>
      
      <guid>https://h3l.github.io/posts/automation-with-applescript-and-keyboard-maestro/</guid>
      <description>介绍 AppleScript 是苹果系统内置的一门语言，主要是可以完成很多普通脚本完成不了的工作，比如打开某个软件，点击某个菜单栏等等操作。
简单学习的话，可以看少数派的这篇文章
Keyboard Maestro是一个将特定的输入和执行动作绑定的一个软件，比如在某个应用按下某个特定的快捷键执行特定的脚本。具体功能可以查看官网，使用方法在安装完软件后会有一个简短的小教程。
 主要需求：为 PDF Expert 的日间操作加上快捷键功能  操作  编写 AppleScript 切换到日间模式  tell application &amp;#34;System Events&amp;#34; tell process &amp;#34;PDF Expert&amp;#34; click menu item &amp;#34;日间&amp;#34; of menu &amp;#34;主题&amp;#34; of menu item &amp;#34;主题&amp;#34; of menu &amp;#34;视图&amp;#34; of menu bar item &amp;#34;视图&amp;#34; of menu bar 1 end tell end tell  在 Keyboard Maestro 给 PDF Expert 配置相应的快捷键对应的操作   可选步骤，将快捷键操作配置为制定应用而不是全局执行。在 Groups 里面新建一个 PDF Expert 的 Group，新建的时候选择 Available in these applications ，之后选中 PDF Expert，最后将上一步新建的 Macros 拖动到 PDF Expert 文件夹。  </description>
    </item>
    
    <item>
      <title>豆瓣 Alfred workflow</title>
      <link>https://h3l.github.io/posts/douban-workflow/</link>
      <pubDate>Thu, 06 Dec 2018 23:24:38 +0800</pubDate>
      
      <guid>https://h3l.github.io/posts/douban-workflow/</guid>
      <description>主要需求是因为经常挑书的时候想看看豆瓣评分是多少，可是又不想每次打开豆瓣去搜索。
之前装的 Alfred 的豆瓣的 workflow 都因为豆瓣 API 的关闭而变得不能用了。
没得办法，只能自己写一个。最开始的时候是尝试抓取电脑版页面的，结果发现豆瓣没以前那么好爬了，所以在 Chrome 里面打了半天的断点调试了半天也没解出来怎么加密数据的。
后面灵机一动，既然电脑做了加密，那么手机呢？最后还是通过手机的页面撸完了这个 workflow。
地址：https://github.com/h3l/douban-workflow
主要功能：
 搜索书籍 搜索电影  截图如下：</description>
    </item>
    
    <item>
      <title>一种低配版服务降级方法</title>
      <link>https://h3l.github.io/posts/low_level_service_downgrade/</link>
      <pubDate>Mon, 22 Oct 2018 20:30:02 +0800</pubDate>
      
      <guid>https://h3l.github.io/posts/low_level_service_downgrade/</guid>
      <description>现在微服务是潮流，大多数时候，不管基础的微服务设施有没有搭建好，大项目能拆出来一个是一个，反正拆开了就是微服务。
所以系统从原来的函数调用，变成了 http 调用或者是 rpc 的调用。
原意是为了方便管理项目，提高灵活性等等，可是变为 http 调用后，服务变得不那么可靠了。
 情况一，虽然服务不可靠，但是挂了就挂了，依赖这个服务的相关服务也挂了，正常 情况了，服务不可靠，而且接口响应时间很慢，那么这个时候，本身的服务可能因为这个服务拖垮。  这个时候也没有所谓的熔断器等等的基础设施。
那么有一种低配版的服务降级方法，就是借助 redis 来实现。伪代码如下：
// 获取当前被阻塞数 unhandledCount := redis.Get(&amp;#34;unhandledCount_FUNC_NAME&amp;#34;) // 大于被阻塞数，直接返回失败 if unhandledCount &amp;gt; MAX_UNHANDLED_COUNT{ return fail }else{ redis.Incr(&amp;#34;unhandledCount_FUNC_NAME) resp := http.get(&amp;#34;http://url&amp;#34;)  redis.Decr(&amp;#34;unhandledCount_FUNC_NAME&amp;#34;) return resp } 这种方法和 timeout 的方法来比的话，最大的好处就是，别的系统再怎么炸，就不会影响自己的系统。所以这种方法不仅适用与微服务的系统调用，所有依赖第三方的调用也可以通过这种方法保障自身服务稳定。
最后，这也只是一个变通的，低配版的方案，要实实在在的解决这个问题，还是要靠正统的方法。</description>
    </item>
    
    <item>
      <title>一种通用型的权限系统设计</title>
      <link>https://h3l.github.io/posts/permission/</link>
      <pubDate>Wed, 19 Sep 2018 20:11:04 +0800</pubDate>
      
      <guid>https://h3l.github.io/posts/permission/</guid>
      <description>先简单看一下简单的表结构以及表关系。
+--------------+ group_id &amp;amp; service_id +----------+ service_id &amp;amp; api_id +-----+ | Group | ------------------------ | Service | ---------------------- | Api | +--------------+ +----------+ +-----+ | | group_id | +--------------+ user_id +----------+ | UserPosition | ------------------------ | User | +--------------+ +----------+ | | org_id | +--------------+ parent_id &amp;amp; child_id +----------+ | Organization | ------------------------ | Relation | +--------------+ +----------+ 表解释  用户相关  User 用于存储用户信息，主要字段为 id 用户信息等   组织相关  Organization 用于存储组织架构中的单个组织，主要字段为 id,name 等等 Relation 用于存储组织架构中的组织间关系，主要字段为parent_id,child_id   群组相关  Group 用于存储群组信息，主要字段为 id 群组名等 Service 用于存储服务信息，主要字段为 id 服务名称等 Api  用于存储接口信息，主要字段为id,url_name,app_name`等 另外还有两张表用于存储 Group 与 Service 的多对多关系以及 Service 与 Api  的多对多关系   将上述关系组织到一起  UserPosition 记录一个人在哪些组织上属于什么群组，主要字段有 user_id, group_id, org_id    概述 上述的那么多表，其实只是解决了一个问题『一个人在什么范围能做什么事情』。</description>
    </item>
    
  </channel>
</rss>