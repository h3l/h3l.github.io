<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>所以然</title>
    <link>https://h3l.github.io/</link>
    <description>Recent content on 所以然</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 22 Oct 2018 20:30:02 +0800</lastBuildDate>
    
	<atom:link href="https://h3l.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>一种低配版服务降级方法</title>
      <link>https://h3l.github.io/posts/low_level_service_downgrade/</link>
      <pubDate>Mon, 22 Oct 2018 20:30:02 +0800</pubDate>
      
      <guid>https://h3l.github.io/posts/low_level_service_downgrade/</guid>
      <description>现在微服务是潮流，大多数时候，不管基础的微服务设施有没有搭建好，大项目能拆出来一个是一个，反正拆开了就是微服务。
所以系统从原来的函数调用，变成了 http 调用或者是 rpc 的调用。
原意是为了方便管理项目，提高灵活性等等，可是变为 http 调用后，服务变得不那么可靠了。
 情况一，虽然服务不可靠，但是挂了就挂了，依赖这个服务的相关服务也挂了，正常 情况了，服务不可靠，而且接口响应时间很慢，那么这个时候，本身的服务可能因为这个服务拖垮。  这个时候也没有所谓的熔断器等等的基础设施。
那么有一种低配版的服务降级方法，就是借助 redis 来实现。伪代码如下：
// 获取当前被阻塞数 unhandledCount := redis.Get(&amp;quot;unhandledCount_FUNC_NAME&amp;quot;) // 大于被阻塞数，直接返回失败 if unhandledCount &amp;gt; MAX_UNHANDLED_COUNT{ return fail }else{ redis.Incr(&amp;quot;unhandledCount_FUNC_NAME) resp := http.get(&amp;quot;http://url&amp;quot;) redis.Decr(&amp;quot;unhandledCount_FUNC_NAME&amp;quot;) return resp }  这种方法和 timeout 的方法来比的话，最大的好处就是，别的系统再怎么炸，就不会影响自己的系统。所以这种方法不仅适用与微服务的系统调用，所有依赖第三方的调用也可以通过这种方法保障自身服务稳定。
最后，这也只是一个变通的，低配版的方案，要实实在在的解决这个问题，还是要靠正统的方法。</description>
    </item>
    
    <item>
      <title>一种通用型的权限系统设计</title>
      <link>https://h3l.github.io/posts/permission/</link>
      <pubDate>Wed, 19 Sep 2018 20:11:04 +0800</pubDate>
      
      <guid>https://h3l.github.io/posts/permission/</guid>
      <description>先简单看一下简单的表结构以及表关系。
+--------------+ group_id &amp;amp; service_id +----------+ service_id &amp;amp; api_id +-----+ | Group | ------------------------ | Service | ---------------------- | Api | +--------------+ +----------+ +-----+ | | group_id | +--------------+ user_id +----------+ | UserPosition | ------------------------ | User | +--------------+ +----------+ | | org_id | +--------------+ parent_id &amp;amp; child_id +----------+ | Organization | ------------------------ | Relation | +--------------+ +----------+  表解释  用户相关  User 用于存储用户信息，主要字段为 id 用户信息等  组织相关  Organization 用于存储组织架构中的单个组织，主要字段为 id,name 等等 Relation 用于存储组织架构中的组织间关系，主要字段为parent_id,child_id  群组相关  Group 用于存储群组信息，主要字段为 id 群组名等 Service 用于存储服务信息，主要字段为 id 服务名称等 Api 用于存储接口信息，主要字段为id,url_name,app_name`等 另外还有两张表用于存储 Group 与 Service 的多对多关系以及 Service 与 Api 的多对多关系  将上述关系组织到一起  UserPosition 记录一个人在哪些组织上属于什么群组，主要字段有 user_id, group_id, org_id   概述 上述的那么多表，其实只是解决了一个问题『一个人在什么范围能做什么事情』。</description>
    </item>
    
  </channel>
</rss>